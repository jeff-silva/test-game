import{l as O,E as W,a as J,C as j,b as tt,A as et,c as R,d as st,e as it,f as ot,i as nt}from"./hVKSCpit.js";import{M as rt,g as M,o as Z,G as at,H as ht,I as mt,l as lt,J as ct,m as dt,B as ut,v as pt,h as yt,k as gt,j as ft,K as bt,N as wt,d as H,t as xt,r as Vt,q as St,s as At,b as kt,i as Ct,E as U,Q as P,c as $,e as X,U as q,L as Mt,X as F,Y as Tt,Z as Bt,w as Et}from"./DQ4UCc7_.js";/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Dt extends rt{constructor(t,e){super(t,e),this.isExtendedMesh=!0,this.isGroup=!1,this.vector3=new M,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class K{constructor(){this._defaultMaterial=new Z({color:13421772})}get(){return this._defaultMaterial}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class vt{constructor(t){this.scene=t,this.isHeadless=t==="headless",this.defaultMaterial=new K}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),capsule:(t={},e={})=>this.makeCapsule(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),capsule:(t={},e={})=>this.addCapsule(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){this.scene!=="headless"&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,s){const{x:n=0,y:o=0,z:i=0}=s;let a;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":a=new ht(t,e);break;case"PointsMaterial":a=new at(t,e);break;default:a=new Dt(t,e);break}return a.position.set(n,o,i),a.castShadow=a.receiveShadow=!0,a}makeExtrude(t,e){const{x:s,y:n,z:o,name:i,shape:a,autoCenter:r=!0,breakable:h=!1,...m}=t,{depth:l=1,bevelEnabled:c=!1}=m,d=new mt(a,{depth:l,bevelEnabled:c,...m}),u=this.addMaterial(e),y=this.createMesh(d,u,{x:s,y:n,z:o});return r&&y.geometry.center(),y.name=i||`body_id_${y.id}`,y.shape="extrude",y}addExtrude(t,e={}){const s=this.makeExtrude(t,e);return this.addExisting(s),s}makePlane(t,e){const{x:s,y:n,z:o,name:i,breakable:a=!1,...r}=t,h=new lt(r.width||1,r.height||1,r.widthSegments||1,r.heightSegments||1),m=this.addMaterial(e);m.side=ct;const l=this.createMesh(h,m,{x:s,y:n,z:o});return l.name=i||`body_id_${l.id}`,l.shape="plane",l}addPlane(t,e){const s=this.makePlane(t,e);return this.addExisting(s),s}makeSphere(t,e){const{x:s,y:n,z:o,name:i,breakable:a=!1,...r}=t,h=new dt(r.radius||1,r.widthSegments||16,r.heightSegments||12,r.phiStart||void 0,r.phiLength||void 0,r.thetaStart||void 0,r.thetaLength||void 0),m=this.addMaterial(e),l=this.createMesh(h,m,{x:s,y:n,z:o});return l.name=i||`body_id_${l.id}`,l.shape="sphere",l}addSphere(t={},e={}){const s=this.makeSphere(t,e);return this.addExisting(s),s}makeBox(t,e){const{x:s,y:n,z:o,name:i,breakable:a=!1,...r}=t,h=new ut(r.width||1,r.height||1,r.depth||1,r.widthSegments||void 0,r.heightSegments||void 0,r.depthSegments||void 0),m=this.addMaterial(e),l=this.createMesh(h,m,{x:s,y:n,z:o});return l.name=i||`body_id_${l.id}`,l.shape="box",l}addBox(t={},e={}){const s=this.makeBox(t,e);return this.addExisting(s),s}addGround(t,e={}){const s=this.makeBox(t,e);return s.rotateX(pt.degToRad(90)),this.addExisting(s),s}makeCapsule(t={},e={}){const{x:s,y:n,z:o,name:i,breakable:a=!1,...r}=t,h=new yt(r.radius||.5,r.length||1,r.capSegments||4,r.radialSegments||16),m=this.addMaterial(e),l=this.createMesh(h,m,{x:s,y:n,z:o});return l.name=i||`body_id_${l.id}`,l.shape="capsule",l}addCapsule(t={},e={}){const s=this.makeCapsule(t,e);return this.addExisting(s),s}makeCylinder(t={},e={}){const{x:s,y:n,z:o,name:i,breakable:a=!1,...r}=t,h=new gt(r.radiusTop||1,r.radiusBottom||1,r.height||1,r.radiusSegments||void 0,r.heightSegments||void 0,r.openEnded||void 0,r.thetaStart||void 0,r.thetaLength||void 0),m=this.addMaterial(e),l=this.createMesh(h,m,{x:s,y:n,z:o});return l.name=i||`body_id_${l.id}`,l.shape="cylinder",l}addCylinder(t={},e={}){const s=this.makeCylinder(t,e);return this.addExisting(s),s}makeCone(t={},e={}){const{x:s,y:n,z:o,name:i,breakable:a=!1,...r}=t,h=new ft(r.radius||1,r.height||1,r.radiusSegments||8,r.heightSegments||1,r.openEnded||!1,r.thetaStart||0,r.thetaLength||2*Math.PI),m=this.addMaterial(e),l=this.createMesh(h,m,{x:s,y:n,z:o});return l.name=i||`body_id_${l.id}`,l.shape="cone",l}addCone(t={},e={}){const s=this.makeCone(t,e);return this.addExisting(s),s}makeTorus(t={},e={}){const{x:s,y:n,z:o,name:i,breakable:a=!1,...r}=t,h=new bt(r.radius||void 0,r.tube||void 0,r.radialSegments||void 0,r.tubularSegments||void 0,r.arc||void 0),m=this.addMaterial(e),l=this.createMesh(h,m,{x:s,y:n,z:o});return l.name=i||`body_id_${l.id}`,l.shape="torus",l}addTorus(t={},e={}){const s=this.makeTorus(t,e);return this.addExisting(s),s}addMaterial(t={}){const e=Object.keys(t)[0];let s;if(this.scene==="headless")return this.defaultMaterial.get();switch(e){case"basic":s=new Ct(t.basic);break;case"normal":s=new kt(t.normal);break;case"standard":s=new At(t.standard);break;case"lambert":s=new Z(t.lambert);break;case"phong":s=new St(t.phong);break;case"physical":typeof t.physical<"u"?s=new Vt(t.physical):(O("You need to pass parameters to the physical material. (Fallback to default material)"),s=this.defaultMaterial.get());break;case"toon":s=new xt(t.toon);break;case"line":s=new H(t.line);break;case"points":s=new wt(t.points);break;case"custom":s=t.custom||this.defaultMaterial.get();break;default:s=this.defaultMaterial.get();break}return s}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Lt{constructor(t,e){this.physics=t,this.ammo=e,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.impact=[],this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new U,this.tmpQuaternion=new P,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new W,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){typeof this.eventEmitter>"u"&&(this.eventEmitter=new W)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",()=>{t()}):this.eventEmitter.on("update",()=>{t()})}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",e=>{const{bodies:s,event:n}=e;s[0].name===this.name?t(s[1],n):s[1].name===this.name&&t(s[0],n)})}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,s){const n=this.tmpEuler.set(t,e,s),o=this.tmpQuaternion.set(0,0,0,1);o.setFromEuler(n),this.tmpBtQuaternion.setValue(0,0,0,1);const i=this.tmpBtQuaternion;i.setValue(o.x,o.y,o.z,o.w),this.physics.worldTransform.setRotation(i)}get rotation(){let t,e,s;const o=this.physics.worldTransform.getRotation();let i=this.tmpQuaternion.set(o.x(),o.y(),o.z(),o.w());i.w>1&&(i=i.normalize());const a=2*Math.acos(i.w),r=Math.sqrt(1-i.w*i.w);return r<.001?(t=i.x,e=i.y,s=i.z):(t=i.x/r,e=i.y/r,s=i.z/r),{x:t*a,y:e*a,z:s*a}}get quaternion(){const e=this.physics.worldTransform.getRotation();return{x:e.x(),y:e.y(),z:e.z(),w:e.w()}}setPosition(t,e,s){this.physics.worldTransform.getOrigin().setValue(t,e,s)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,e){this.ammo.setDamping(t,e)}setGravity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Pt{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const s=this.factory.add.plane(t,e);return this.addExisting(s,t),s}addSphere(t={},e={}){const s=this.factory.add.sphere(t,e);return this.addExisting(s,t),s}addBox(t={},e={}){const s=this.factory.add.box(t,e);return this.addExisting(s,t),s}addGround(t,e={}){const s=this.factory.add.ground(t,e),n={...t,mass:0,collisionFlags:1};return this.addExisting(s,n),s}addCapsule(t={},e={}){const s=this.factory.add.capsule(t,e);return this.addExisting(s,t),s}addCylinder(t={},e={}){const s=this.factory.add.cylinder(t,e);return this.addExisting(s,t),s}addCone(t={},e={}){const s=this.factory.add.cone(t,e);return this.addExisting(s,t),s}addTorus(t={},e={}){const s=this.factory.add.torus(t,e);return this.addExisting(s,t),s}addExtrude(t,e={}){const s=this.factory.add.extrude(t,e);return s.translateX(1),this.addExisting(s),s}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class zt{constructor(t,e){this.worldTransform=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(typeof(t==null?void 0:t.x)<"u"?t.x:e,typeof(t==null?void 0:t.y)<"u"?t.y:e,typeof(t==null?void 0:t.z)<"u"?t.z:e)}get addConstraints(){return{lock:(t,e,s)=>this.lock(t,e,s),fixed:(t,e,s)=>this.fixed(t,e,s),pointToPoint:(t,e,s,n)=>this.pointToPoint(t,e,s,n),hinge:(t,e,s,n)=>this.hinge(t,e,s,n),slider:(t,e,s={},n)=>this.slider(t,e,s,n),spring:(t,e,s={},n)=>this.spring(t,e,s,n),coneTwist:(t,e,s={frameA:{},frameB:{}},n)=>this.coneTwist(t,e,s,n),dof:(t,e,s,n)=>this.dof(t,e,s,n)}}getTransform(t,e,s={x:0,y:0,z:0},n=!1){s={x:0,y:0,z:0,...s};const o=(a,r)=>{var h=(a.x()-r.x())/2+s.x,m=(a.y()-r.y())/2+s.y,l=(a.z()-r.z())/2+s.z;return new Ammo.btVector3(h,m,l)},i=new Ammo.btTransform;if(i.setIdentity(),n){const a=o(t.getWorldTransform().getOrigin(),e.getWorldTransform().getOrigin()),r=new Ammo.btTransform;r.setIdentity(),r.setOrigin(a);const h=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return h.op_mul(r),{transformA:h,transformB:r}}else return i.setOrigin(new Ammo.btVector3(s.x,s.y,s.z)),{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(i),transformB:i}}lock(t,e,s=!0){const n={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:n,angularUpperLimit:n},s)}fixed(t,e,s=!0){const n=this.getTransform(t.ammo,e.ammo);n.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),n.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const o=new Ammo.btFixedConstraint(t.ammo,e.ammo,n.transformA,n.transformB);return this.physicsWorld.addConstraint(o,s),o}pointToPoint(t,e,s={},n=!0){const{pivotA:o,pivotB:i}=s,a=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),r=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),h=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,a,r);return this.physicsWorld.addConstraint(h,n),h}hinge(t,e,s={},n=!0){const{pivotA:o,pivotB:i,axisA:a,axisB:r}=s,h=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),m=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),l=new Ammo.btVector3((a==null?void 0:a.x)||0,(a==null?void 0:a.y)||0,(a==null?void 0:a.z)||0),c=new Ammo.btVector3((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,h,m,l,c,!0);return this.physicsWorld.addConstraint(d,n),d}slider(t,e,s={},n=!0){const o=this.getTransform(t.ammo,e.ammo),{frameA:i={},frameB:a={},linearLowerLimit:r=0,linearUpperLimit:h=0,angularLowerLimit:m=0,angularUpperLimit:l=0}=s,c=o.transformA.getRotation();c.setEulerZYX(i.x||0,i.y||0,i.z||0),o.transformA.setRotation(c);const d=o.transformB.getRotation();d.setEulerZYX(a.x||0,a.y||0,a.z||0),o.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,o.transformA,o.transformB,!0);return u.setLowerLinLimit(r),u.setUpperLinLimit(h),u.setLowerAngLimit(m),u.setUpperAngLimit(l),this.physicsWorld.addConstraint(u,n),u}spring(t,e,s={},n=!0){const{stiffness:o=50,damping:i=.01,angularLock:a=!1,linearLowerLimit:r={},linearUpperLimit:h={},angularLowerLimit:m={},angularUpperLimit:l={},offset:c={},center:d=!1,enableSpring:u=!0}=s,y={x:0,y:0,z:0,...c},w=this.getTransform(t.ammo,e.ammo,y,d),p=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,w.transformA,w.transformB,!0);this.tmpBtVector3.setValue(r.x||0,r.y||0,r.z||0),p.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(h.x||0,h.y||0,h.z||0),p.setLinearUpperLimit(this.tmpBtVector3),a?(this.tmpBtVector3.setValue(0,0,0),p.setAngularLowerLimit(this.tmpBtVector3),p.setAngularUpperLimit(this.tmpBtVector3)):(console.log(m,l),p.setAngularLowerLimit(this.toAmmoV3(m,-Math.PI)),p.setAngularUpperLimit(this.toAmmoV3(l,Math.PI)));for(let V=0;V<3;V++)p.enableSpring(V,u),p.setStiffness(V,o),p.setDamping(V,i);return this.physicsWorld.addConstraint(p,n),p}coneTwist(t,e,s,n=!0){const{frameA:o,frameB:i}=s,a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0);const r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),this.getTransform(t.ammo,e.ammo);const h=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,a,r);return h.setAngularOnly(!0),this.physicsWorld.addConstraint(h,n),h}dof(t,e,s={},n=!0){const{offset:o,center:i=!1}=s,a={x:0,y:0,z:0,...o},r=this.getTransform(t.ammo,e.ammo,a,i),h=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,r.transformA,r.transformB,!0),{linearLowerLimit:m,linearUpperLimit:l,angularLowerLimit:c,angularUpperLimit:d}=s,u=this.toAmmoV3(m),y=this.toAmmoV3(l),w=this.toAmmoV3(c,-Math.PI),p=this.toAmmoV3(d,Math.PI);return h.setLinearLowerLimit(u),h.setLinearUpperLimit(y),h.setAngularLowerLimit(w),h.setAngularUpperLimit(p),Ammo.destroy(u),Ammo.destroy(y),Ammo.destroy(w),Ammo.destroy(p),this.physicsWorld.addConstraint(h,n),h}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */const _t=(f,t)=>{const{radius:e=1,tube:s=.4,tubularSegments:n=8}=f,o=Math.PI,i=n,a=Math.sqrt(2*s*s-2*s*s*Math.cos(2*o/i)),r=new Ammo.btVector3(s,o/i+.5*a,s),h=new Ammo.btCylinderShape(r);h.setMargin(.05);const m=new Ammo.btCompoundShape,l=new Ammo.btVector3(0,0,1),c=new Ammo.btVector3(0,e,0),d=new Ammo.btQuaternion(t.x,t.y,t.z,t.w);for(let u=0;u<i;u++){const y=u*2*o/i,w=c.rotate(l,y),p=new Ammo.btTransform;d.setRotation(l,y+Math.PI/2),p.setIdentity(),p.setOrigin(w),p.setRotation(d),m.addChildShape(p,h)}return m};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Ot extends W{addCollider(t,e,s){!t.body||!e.body||(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",n=>{var a,r;const{bodies:o,event:i}=n;(a=o[0])!=null&&a.name&&((r=o[1])!=null&&r.name)&&(t!=null&&t.name)&&(e!=null&&e.name)&&(o[0].name===t.name&&o[1].name===e.name||o[1].name===t.name&&o[0].name===e.name)&&s(i)}))}}/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
 * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
 */const Y={NoDebug:0,DrawWireframe:1,DrawAabb:2,DrawFeaturesText:4,DrawContactPoints:8,NoDeactivation:16,NoHelpText:32,DrawText:64,ProfileTimings:128,EnableSatComparison:256,DisableBulletLCP:512,EnableCCD:1024,DrawConstraints:2048,DrawConstraintLimits:4096,FastWireframe:8192,DrawNormals:16384,DrawOnTop:32768,MAX_DEBUG_DRAW_MODE:4294967295};class Wt{constructor(t,e,s={}){this.scene=t,this.world=e,this.options=s,this.debugDrawMode=s.debugDrawMode||Y.DrawWireframe;const n=this.debugDrawMode&Y.DrawOnTop||!1,o=s.maxBufferSize||1e6;this.geometry=new $;const i=new Float32Array(o*3),a=new Float32Array(o*3);this.geometry.setAttribute("position",new X(i,3).setUsage(q)),this.geometry.setAttribute("color",new X(a,3).setUsage(q)),this.index=0;const r=new H({vertexColors:!0,depthTest:!n});this.mesh=new Mt(this.geometry,r),n&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(this.index!=0&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,s){const n=Ammo.HEAPF32,o=n[(s+0)/4],i=n[(s+4)/4],a=n[(s+8)/4],r=n[(t+0)/4],h=n[(t+4)/4],m=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,r,h,m),this.geometry.attributes.color.setXYZ(this.index++,o,i,a);const l=n[(e+0)/4],c=n[(e+4)/4],d=n[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,l,c,d),this.geometry.attributes.color.setXYZ(this.index++,o,i,a)}drawContactPoint(t,e,s,n,o){const i=Ammo.HEAPF32,a=i[(o+0)/4],r=i[(o+4)/4],h=i[(o+8)/4],m=i[(t+0)/4],l=i[(t+4)/4],c=i[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,m,l,c),this.geometry.attributes.color.setXYZ(this.index++,a,r,h);const d=i[(e+0)/4]*s,u=i[(e+4)/4]*s,y=i[(e+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,m+d,l+u,c+y),this.geometry.attributes.color.setXYZ(this.index++,a,r,h)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}}const Yt=(f,t)=>{typeof window<"u"&&(window.__loadPhysics=!0),J(f,()=>{Ammo().then(()=>{t()})})};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Nt extends W{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless=t==="headless",this.tmpEuler=new U,this.tmpQuaternion=new P,this.tmpVector3=new M,this.tmpVector3a=new M,this.tmpMatrix4=new F,this.tmpMatrix4a=new F,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new M,this.impactPoint=new M,this.impactNormal=new M,t!=="headless"&&(this.defaultMaterial=new K),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var o;const e=Object.keys(t).includes("body")?t.body:t;if(typeof(e==null?void 0:e.ammo)>"u")return;let s=e.ammo.threeObject;const n=s.name;if(n&&s&&(o=s==null?void 0:s.body)!=null&&o.ammo){s.body.isSoftBody?this.physicsWorld.removeSoftBody(s.body.ammo):this.physicsWorld.removeRigidBody(s.body.ammo),s.body.destructor(),s.body=void 0,s.hasBody=!1,delete e.ammo.threeObject;for(let i=0;i<this.rigidBodies.length;i++)this.rigidBodies[i].name===n&&(this.rigidBodies.splice(i,1),i--)}this.scene==="headless"&&s&&(s=null)}setup(){if(this.worldTransform=new Ammo.btTransform,typeof this.config.setupPhysicsWorld=="function"?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),this.scene!=="headless"){this.convexBreaker=new j,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new Ot,this.factory=new vt(this.scene),this.shapes=new Pt(this.factory,(t,e)=>this.addExisting(t,e)),this.constraints=new zt(this.worldTransform,this.physicsWorld),this.scene!=="headless"&&(this.debugDrawer=new Wt(this.scene,this.physicsWorld,{}))}updateDebugger(){this.scene!=="headless"&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let s;if(!e){const n=new Ammo.btDefaultCollisionConfiguration,o=new Ammo.btCollisionDispatcher(n),i=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver;s=new Ammo.btDiscreteDynamicsWorld(o,i,a,n)}if(e){const n=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,o=new Ammo.btCollisionDispatcher(n),i=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver,r=new Ammo.btDefaultSoftBodySolver;s=new Ammo.btSoftRigidDynamicsWorld(o,i,a,n,r)}return s.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),s}createDebrisFromBreakableObject(t,e){this.scene!=="headless"&&(t.material=e.material,t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,t.name=`${e.name}__DEBRIS_${t.id}`,this.scene.add(t),this.addExisting(t,{autoCenter:!0}),t.body.fractureImpulse=e.body.fractureImpulse,t.body.breakable=!1,setTimeout(()=>{t.body.breakable=!0},2500))}removeDebris(t){this.scene!=="headless"&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let s=0;s<this.rigidBodies.length;s++){const n=this.rigidBodies[s];n.body.impact=[];const i=n.body.ammo.getMotionState();if(i){if(i.getWorldTransform(this.worldTransform),n.body.didUpdate&&(n.body._emitUpdateEvents&&n.body.eventEmitter.emit("update"),n.body.didUpdate=!1),n.body.ammo.isKinematicObject()&&n.body.needUpdate)n.getWorldQuaternion(this.tmpQuaternion),n.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),i.setWorldTransform(this.worldTransform),n.body.needUpdate=!1;else if(!n.body.skipUpdate){if(!n.body.ammo.isStaticObject()){const a=this.worldTransform.getOrigin(),r=this.worldTransform.getRotation(),h=n.body.offset;if(n.body.ignoreScale)this.tmpVector3a.set(n.scale.x,n.scale.y,n.scale.z);else{const m=n.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(m.x(),m.y(),m.z())}this.tmpVector3.set(a.x()+h.x,a.y()+h.y,a.z()+h.z),this.tmpQuaternion.set(r.x(),r.y(),r.z(),r.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),n.parent?parseInt(Tt)>=123?this.tmpMatrix4a.copy(n.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(n.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(n.position,n.quaternion,n.scale)}}}}}detectCollisions(){var n,o;const t=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const e=this.physicsWorld.getDispatcher(),s=e.getNumManifolds();for(let i=0;i<s;i++){const a=e.getManifoldByIndexInternal(i),r=a.getNumContacts(),h=Ammo.castObject(a.getBody0(),Ammo.btRigidBody),m=Ammo.castObject(a.getBody1(),Ammo.btRigidBody),l=h.threeObject,c=m.threeObject;if(!l||!c||h.name===""&&m.name==="")continue;const d=(n=l.body)==null?void 0:n.checkCollisions,u=(o=c.body)==null?void 0:o.checkCollisions,y=l.body.breakable,w=c.body.breakable,p=l.body.fractureImpulse,V=c.body.fractureImpulse,T=d||u,B=y||w;if(typeof l.fragmentDepth>"u"&&(l.fragmentDepth=0),typeof c.fragmentDepth>"u"&&(c.fragmentDepth=0),!T&&!B)continue;let C=!1,E=0,z="start";for(let g=0;g<r;g++){const b=a.getContactPoint(g);if(b.getDistance()<=0){C=!0;const S=b.getAppliedImpulse(),x=b.get_m_positionWorldOnB(),A=b.get_m_normalWorldOnB();if(d||u){const Q=[l.uuid,c.uuid].sort(),I=`${Q[0]}__${Q[1]}`;if(this.earlierDetectedCollisions.find(D=>D.combinedName===I)&&(z="collision"),!t.find(D=>D.combinedName===I)){t.push({combinedName:I,collision:!0});const D={x:x.x(),y:x.y(),z:x.z()},G={x:A.x(),y:A.y(),z:A.z()};l.body.impact.push({impulse:S,point:D,normal:G,name:c.name}),c.body.impact.push({impulse:S,point:D,normal:G,name:l.name}),this.collisionEvents.emit("collision",{bodies:[l,c],event:z})}}S>=E&&(E=S,(y||w)&&(this.impactPoint.set(x.x(),x.y(),x.z()),this.impactNormal.set(A.x(),A.y(),A.z())));break}}if(!C||!B)continue;const _=2;if(this.emptyV3.set(0,0,0),l.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:y,physicsBody:h},c.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:w,physicsBody:m},y&&E>p&&l.fragmentDepth<_){const g=this.convexBreaker.subdivideByImpact(l,this.impactPoint,this.impactNormal,1,2),b=g.length;for(let k=0;k<b;k++){const S=h.getLinearVelocity(),x=h.getAngularVelocity(),A=g[k];A.userData.ammoPhysicsData.velocity.set(S.x(),S.y(),S.z()),A.userData.ammoPhysicsData.angularVelocity.set(x.x(),x.y(),x.z()),this.createDebrisFromBreakableObject(A,l)}this.objectsToRemove[this.numObjectsToRemove++]=l}if(w&&E>V&&c.fragmentDepth<_){const g=this.convexBreaker.subdivideByImpact(c,this.impactPoint,this.impactNormal,1,2),b=g.length;for(let k=0;k<b;k++){const S=m.getLinearVelocity(),x=m.getAngularVelocity(),A=g[k];A.userData.ammoPhysicsData.velocity.set(S.x(),S.y(),S.z()),A.userData.ammoPhysicsData.angularVelocity.set(x.x(),x.y(),x.z()),this.createDebrisFromBreakableObject(A,c)}this.objectsToRemove[this.numObjectsToRemove++]=c}}for(let i=0;i<this.numObjectsToRemove;i++)this.removeDebris(this.objectsToRemove[i]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(i=>{const{combinedName:a}=i;if(!t.find(r=>r.combinedName===a)){const r=a.split("__"),h=this.rigidBodies.find(c=>c.uuid===r[0]),m=this.rigidBodies.find(c=>c.uuid===r[1]);h&&m&&this.collisionEvents.emit("collision",{bodies:[h,m],event:"end"})}}),this.earlierDetectedCollisions=[...t]}setGravity(t=0,e=-9.8,s=0){this.tmpBtVector3.setValue(t,e,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){if(typeof Ammo>"u"){O("Are you sure you included ammo.js?");return}typeof Ammo=="function"?Ammo().then(()=>{this.setup()}):this.setup()}get add(){return{collider:(t,e,s)=>this.collisionEvents.addCollider(t,e,s),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),capsule:(t={},e={})=>this.shapes.addCapsule(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>t==="closest"?new tt(this):new et(this)}}prepareThreeObjectForCollisionShape(t,e={}){var r,h;const{autoCenter:s=!1}=e,n={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let o="unknown";const i=((r=t.geometry)==null?void 0:r.type)||"unknown";/box/i.test(i)?o="box":/cone/i.test(i)?o="cone":/cylinder/i.test(i)?o="cylinder":/extrude/i.test(i)?o="extrude":/plane/i.test(i)?o="plane":/sphere/i.test(i)?o="sphere":/torus/i.test(i)&&(o="torus");let a={...n,...(h=t==null?void 0:t.geometry)==null?void 0:h.parameters};if(e.shape?(a={...n,...e},o=e.shape):t.shape&&(o=t.shape),Object.keys(a).forEach(m=>{typeof a[m]>"u"&&n[m]&&(a[m]=n[m])}),s){if(t.isMesh&&t.geometry)t.geometry.center();else if(t.isGroup){const m=new Bt,l=new M;m.setFromObject(t).getCenter(l),t.traverse(c=>{c.isMesh&&c.geometry.translate(-l.x,-l.y,-l.z)})}}return o==="cylinder"&&(a.radius=e.radius||a.radiusTop),o==="extrude"&&(o="hacd"),(o==="mesh"||o==="convex")&&(o="convexMesh"),o==="concave"&&(o="concaveMesh"),o==="unknown"&&(O(`Shape for ${t==null?void 0:t.name} not recognized! Will fallback to box.`),o="box"),{shape:o,params:a,object:t}}createCollisionShape(t,e,s){const n=s!=null&&s.quaternion?s==null?void 0:s.quaternion:new P(0,0,0,1),{axis:o="y"}=e,i=new Ammo.btVector3,a=s==null?void 0:s.geometry;s&&(a!=null&&a.isGeometry)&&(s.geometry=new $().fromGeometry(a));const r=u=>{const y=new F().elements,w=[],p=[],V=[];return nt(u,{},(T,B,C)=>{w.push(T),p.push(B),V.push(C)}),{vertices:w,matrices:p,indexes:V,matrixWorld:y}};let h={};this.complexShapes.indexOf(t)!==-1&&(h=r(s));let m;switch(t){case"box":i.setValue(e.width/2,e.height/2,e.depth/2),m=new Ammo.btBoxShape(i);break;case"sphere":m=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(o){case"y":i.setValue(e.radius,e.height/2,e.radius),m=new Ammo.btCylinderShape(i);break;case"x":i.setValue(e.height/2,e.radius,e.radius),m=new Ammo.btCylinderShapeX(i);break;case"z":i.setValue(e.radius,e.radius,e.height/2),m=new Ammo.btCylinderShapeZ(i);break}break;case"cone":switch(o){case"y":m=new Ammo.btConeShape(e.radius,e.height);break;case"x":m=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":m=new Ammo.btConeShapeZ(e.radius,e.height);break}break;case"capsule":switch(o){case"y":m=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":m=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":m=new Ammo.btCapsuleShapeZ(e.radius,e.height);break}break;case"torus":m=_t(e,n);break;case"plane":m=R(h.vertices,h.matrices,h.indexes,h.matrixWorld,{...e,concave:!1});break;case"hull":m=ot(h.vertices,h.matrices,h.matrixWorld,e);break;case"hacd":m=it(h.vertices,h.matrices,h.indexes,h.matrixWorld,e);break;case"vhacd":m=st(h.vertices,h.matrices,h.indexes,h.matrixWorld,e);break;case"convexMesh":m=R(h.vertices,h.matrices,h.indexes,h.matrixWorld,{...e,concave:!1});break;case"concaveMesh":m=R(h.vertices,h.matrices,h.indexes,h.matrixWorld,{...e,concave:!0});break}Ammo.destroy(i);const{x:l,y:c,z:d}=e;return(l||c||d)&&(m._compoundOffset={x:l||0,y:c||0,z:d||0}),Array.isArray(m)&&(m=this.mergeCollisionShapesToCompoundShape(m)),m}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach(s=>{const{_childOffset:n,_compoundOffset:o}=s;if(n){const{pos:i,quat:a,scale:r,margin:h}=n,m=this.applyPosQuatScaleMargin(s,i,a,r,h);e.addChildShape(m,s)}else if(o){const i=new Ammo.btTransform;i.setIdentity(),i.setOrigin(new Ammo.btVector3(o.x,o.y,o.z)),e.addChildShape(i,s)}else{const i=new Ammo.btTransform;i.setIdentity(),e.addChildShape(i,s)}}),e}addExisting(t,e={}){const{hasBody:s}=t;if(s){O(`Object "${t.name}" already has a physical body!`);return}const n=new M,o=new P,i=new M;t.getWorldPosition(n),t.getWorldQuaternion(o),t.getWorldScale(i);const a=(e.collisionFlags||0).toString(2).slice(-1)==="1",r=(e.collisionFlags||0).toString(2).slice(-2,-1)==="1",{shape:h="unknown",compound:m=[],mass:l=a||r?0:1,collisionFlags:c=0,collisionGroup:d=1,collisionMask:u=-1,offset:y=void 0,breakable:w=!1,addChildren:p=!0,margin:V=.01,ignoreScale:T=!1,fractureImpulse:B=1}=e;if(T&&i.set(1,1,1),m.length>=1){const g=m.map(x=>this.createCollisionShape(x.shape,x)),b=this.mergeCollisionShapesToCompoundShape(g),k=this.applyPosQuatScaleMargin(b,n,o,i,V),S=this.collisionShapeToRigidBody(b,k,l,r);this.addRigidBodyToWorld(t,S,c,d,u,y),t.body.breakable=w,t.body.fractureImpulse=B,t.body.ignoreScale=T;return}const C=[];if(h!=="unknown"||t.isMesh){const g=this.prepareThreeObjectForCollisionShape(t,e),b=this.createCollisionShape(g.shape,g.params,g.object);C.push(b)}if(h==="unknown"&&p&&t.children.length>=1&&t.children.forEach(g=>{if(g.isMesh){const b=this.prepareThreeObjectForCollisionShape(g),k=this.createCollisionShape(b.shape,b.params,b.object);k._childOffset={pos:g.position.clone(),quat:g.quaternion.clone(),scale:g.scale.clone(),margin:V},C.push(k)}}),C.length===0){const g=this.prepareThreeObjectForCollisionShape(t,e),b=this.createCollisionShape(g.shape,g.params,g.object);C.push(b)}const E=C.length===1?C[0]:this.mergeCollisionShapesToCompoundShape(C),z=this.applyPosQuatScaleMargin(E,n,o,i,V),_=this.collisionShapeToRigidBody(E,z,l,r);this.addRigidBodyToWorld(t,_,c,d,u,y),t.body.breakable=w,t.body.fractureImpulse=B,t.body.ignoreScale=T}addRigidBodyToWorld(t,e,s,n,o,i){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e,n,o);const a=Object.values(e)[0];t.name||(t.name=`object-${t.id}`),e.name=t.name,t.body=new Lt(this,e),t.hasBody=!0,t.ptr=a,e.threeObject=t,i&&(t.body.offset={x:0,y:0,z:0,...i}),t.body.setCollisionFlags(s)}applyPosQuatScaleMargin(t,e=new M,s=new P,n=new M,o=.01){t.setMargin(o);const i=new Ammo.btQuaternion(0,0,0,1);i.setValue(s.x,s.y,s.z,s.w);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(e.x,e.y,e.z),a.setRotation(i),Ammo.destroy(i);const r=new Ammo.btVector3(n.x,n.y,n.z);return t.setLocalScaling(r),Ammo.destroy(r),a}collisionShapeToRigidBody(t,e,s,n){const o=new Ammo.btDefaultMotionState(e),i=new Ammo.btVector3(0,0,0);s>0&&t.calculateLocalInertia(s,i);const a=new Ammo.btRigidBodyConstructionInfo(s,o,t,i),r=new Ammo.btRigidBody(a);return(s>0||n)&&r.setActivationState(4),r}}const v=new U(0,0,0,"YXZ"),L=new M,It={type:"change"},Rt={type:"lock"},Ft={type:"unlock"},N=Math.PI/2;class Zt extends Et{constructor(t,e=null){super(t,e),this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,this._onMouseMove=Ut.bind(this),this._onPointerlockChange=Qt.bind(this),this._onPointerlockError=Gt.bind(this),this.domElement!==null&&this.connect()}connect(){this.domElement.ownerDocument.addEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this._onPointerlockError)}disconnect(){this.domElement.ownerDocument.removeEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this._onPointerlockError)}dispose(){this.disconnect()}getObject(){return console.warn("THREE.PointerLockControls: getObject() has been deprecated. Use controls.object instead."),this.object}getDirection(t){return t.set(0,0,-1).applyQuaternion(this.object.quaternion)}moveForward(t){if(this.enabled===!1)return;const e=this.object;L.setFromMatrixColumn(e.matrix,0),L.crossVectors(e.up,L),e.position.addScaledVector(L,t)}moveRight(t){if(this.enabled===!1)return;const e=this.object;L.setFromMatrixColumn(e.matrix,0),e.position.addScaledVector(L,t)}lock(){this.domElement.requestPointerLock()}unlock(){this.domElement.ownerDocument.exitPointerLock()}}function Ut(f){if(this.enabled===!1||this.isLocked===!1)return;const t=f.movementX||f.mozMovementX||f.webkitMovementX||0,e=f.movementY||f.mozMovementY||f.webkitMovementY||0,s=this.object;v.setFromQuaternion(s.quaternion),v.y-=t*.002*this.pointerSpeed,v.x-=e*.002*this.pointerSpeed,v.x=Math.max(N-this.maxPolarAngle,Math.min(N-this.minPolarAngle,v.x)),s.quaternion.setFromEuler(v),this.dispatchEvent(It)}function Qt(){this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(Rt),this.isLocked=!0):(this.dispatchEvent(Ft),this.isLocked=!1)}function Gt(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}export{Nt as A,Zt as P,Yt as a};
